* 응집도와 결합도
  * 응집도(Cohesion)
    *  모듈이 하나의 목적을 수행하는 요소들간의 연관성 척도
    * 모듈 내부의 기능적인 응집 정도를 나타냄
  * 결합도(Coupling)
    * 모듈이 다른 모듈에 의존하는 정도의 척도
    * 모듈과 모듈 간의 상호 결합 정도를 나타냄
  * 응집도는 높게(모듈이 하나의 특정 작업이나 기능에 집중), 결합도는 낮게(모듈이 서로 독립적으로 작동할 수 있을 때)

* 좋은 코드를 위해 의식해야 하는 6가지 코드 작성의 원칙
  * DRY(Don't Repeat Yourselt) : 중복 코드가 있다면 메소드로 분리한다.
  * PIE(Program Intently and Expressively) : 애매한 이름은 쓰지 않고, 컨벤션은 따르고, 매직 넘버에 이름 붙이기
  * SRP(Single Responsibility Principle) : 클래스는 하나의 책임만 가져야 한다. 외부 객체는 생성자로 주입
  * OCP(Open Closed Principle) : 개방 폐쇄 원칙, 확장에 대해서는 열려 있고, 변경에 대해서는 닫혀있다.
  * SDP(Single Dependencies Principle): 수정될 가능성이 없는 클래스에 의존(가장 좋은것은 특정 클래스가 아니라 인터페이스에 의존)
  * ADP(Acyclic Dependencies Principle): 의존성 비순환의 원칙, 의존 관계에 사이클이 발생되지 않게 한다.
  
* SOLID 원칙
* | 원칙                       | 이름                              | 설명                                                                                 |
  |--------------------------|----------------------------------|------------------------------------------------------------------------------------|
  | **S**                   | 단일 책임 원칙 (Single Responsibility Principle) | 하나의 클래스는 하나의 책임만 가져야 하며, 변경 이유도 하나뿐이어야 한다.                                         |
  | **O**                   | 개방-폐쇄 원칙 (Open/Closed Principle)        | 소프트웨어 요소는 **확장에는 열려 있어야 하고**, **수정에는 닫혀 있어야 한다.**                                  |
  | **L**                   | 리스코프 치환 원칙 (Liskov Substitution Principle) | 자식 클래스는 부모 클래스를 대체할 수 있어야 한다. 즉, 부모 객체 대신 자식 객체를 사용해도 정상적으로 작동해야 한다. <br/> is a 원칙 |
  | **I**                   | 인터페이스 분리 원칙 (Interface Segregation Principle) | 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.                                         |
  | **D**                   | 의존 역전 원칙 (Dependency Inversion Principle)   | 고수준 모듈은 저수준 모듈에 의존하면 안 되며, **추상화에 의존해야 한다.** 또한, **구현이 아닌 인터페이스에 의존**해야 한다.        |

* 디자인 패턴 : 설계 원칙과 노하우를 정리한 것

* ## GoF의 23가지 디자인 패턴

### 생성(Creational) 패턴
| 패턴 이름         | 설명                                                           |
|------------------|--------------------------------------------------------------|
| Singleton        | 클래스의 인스턴스를 하나만 생성하고, 어디서든 그 인스턴스를 접근할 수 있게 함.                |
| Factory Method   | 객체 생성을 서브클래스에서 처리하도록 위임하여, 클라이언트 코드와 생성 코드의 분리.              |
| Abstract Factory | 관련된 객체들의 집합을 생성하는 인터페이스 제공. 구체적인 클래스는 서브클래스가 결정.             |
| Builder          | 복잡한 객체 생성을 단계별로 처리하며, 동일한 생성 과정으로 다양한 표현 가능.  (StringBuffer) |
| Prototype        | 기존 객체를 복사해서 새 객체를 생성 (clone) 함으로써 객체 생성 비용 절감.               |

### 구조(Structural) 패턴
| 패턴 이름         | 설명                                                   |
|------------------|------------------------------------------------------|
| Adapter          | 인터페이스 호환이 안 되는 클래스들을 함께 작동하게 연결해주는 중간자 역할.           |
| Bridge           | 구현부에서 추상층을 분리하여 각자 독립적으로 확장 가능하게 함.                  |
| Composite        | 트리 구조를 활용해 부분-전체 계층을 동일한 방식으로 다룰 수 있게 함.             |
| Decorator        | 객체에 기능을 동적으로 추가할 수 있게 해주는 패턴. 상속보다 유연한 기능 확장 방식 제공.  |
| Facade           | 복잡한 서브시스템에 대한 단순한 인터페이스 제공.     ex)library, http 패키지 |
| Flyweight        | 동일하거나 유사한 객체를 공유하여 메모리 절약.                           |
| Proxy            | 실제 객체 대신 대리 객체를 통해 접근 제어, 로깅, 지연 로딩 등을 제공.           |

### 행위(Behavioral) 패턴
| 패턴 이름           | 설명                                                                 |
|--------------------|----------------------------------------------------------------------|
| Chain of Responsibility | 요청을 처리할 수 있는 객체들을 체인으로 연결하여, 순차적으로 처리 기회를 부여.             |
| Command             | 요청을 객체로 캡슐화하여 실행 취소, 재실행, 로깅 등을 가능하게 함.                          |
| Interpreter         | 언어의 문법 표현을 클래스로 구성하고, 해석기를 만들어 문장을 해석.                          |
| Iterator            | 컬렉션 내부 구조에 상관없이 순차적으로 요소를 접근할 수 있는 방법 제공.                      |
| Mediator            | 객체 간 복잡한 상호작용을 중재자 객체로 캡슐화하여 객체 간 결합도 감소.                    |
| Memento             | 객체 상태를 저장하고 복원할 수 있게 함. (Undo 기능 등에 사용)                              |
| Observer            | 한 객체의 상태 변화가 있을 때 관련 객체들에게 자동으로 알림. (발행-구독 모델)               |
| State               | 객체의 상태에 따라 행동을 바꾸며, 상태를 객체로 캡슐화.                                     |
| Strategy            | 알고리즘을 객체로 캡슐화하여 동적으로 교체 가능하게 함.                                    |
| Template Method     | 알고리즘의 뼈대를 정의하고 일부 단계를 서브클래스에서 구현하도록 위임.                      |
| Visitor             | 객체 구조를 변경하지 않고 새로운 기능을 추가할 수 있도록 함.                              |


* 아키텍쳐 디자인 패턴
* MVC, MVC2, MVP, MVVM, MVI
* ## 아키텍처 디자인 패턴 비교

| 패턴   | 구성 요소                | 역할 설명                                                                 | View와 Model 관계 | 주요 특징                                                    |
|--------|-------------------------|--------------------------------------------------------------------------|-------------------|-------------------------------------------------------------|
| MVC    | Model, View, Controller | Controller가 입력을 받아 Model 업데이트, View 갱신                         | 서로 참조함        | 전통적인 구조, View와 Model이 직접 통신                    |
| MVC2   | Model, View, Controller | Web 기반 MVC로, View와 Controller가 완전히 분리됨                          | 간접적 관계        | 웹 애플리케이션에서 사용 (예: Java Servlet + JSP)         |
| MVP    | Model, View, Presenter  | Presenter가 모든 로직 처리, View는 단순 표시만 담당                         | 간접적 관계        | 테스트 용이, View → Presenter → Model 단방향 흐름         |
| MVVM   | Model, View, ViewModel  | ViewModel이 Model과 View 사이 중개자 역할, 바인딩으로 데이터 자동 반영     | 바인딩 (자동)      | 데이터 바인딩 기반 (Android, SwiftUI, WPF 등에서 사용)     |
| MVI    | Model, View, Intent     | 상태(State) 기반 단방향 흐름: Intent → Model → View                        | 단방향             | 불변 상태와 단방향 데이터 흐름, 상태 관리에 용이 (Jetpack Compose 등) |

* ## 최종 목적지인 MVVM 기반의 클린 아키텍처 구조
UI Layer ← Flutter 영역

↓

Domain Layer (optional) ← Dart 영역

↓

Data Layer ← Dart & Flutter 영역 ├── Repositories └── Data Sources